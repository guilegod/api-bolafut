generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  user
  owner        // organizador
  arena_owner  // dono de arena/estabelecimento
  admin
}

enum CourtType {
  FUTSAL
  FUT7
  CAMPO
  VOLEI
  FUTVOLEI
  BEACH_TENNIS
  BASQUETE
  TENIS
  HANDEBOL
  SKATE
  OUTRO
}

model User {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  phone     String?

  password  String
  role      Role     @default(user)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // (LEGADO) ainda funciona: quadras ligadas direto no arena_owner
  courts Court[] @relation("ArenaOwnerCourts")

  // ✅ arenas do arena_owner
  arenas Arena[] @relation("ArenaOwnerArenas")

  // partidas criadas por organizador
  matches Match[] @relation("OrganizerMatches")

  // parcerias do organizador com arenas
  partnerships PartnerArena[] @relation("OrganizerPartnerships")

  // presenças do usuário nas partidas
  presences MatchPresence[]

  // chat da partida
  messages MatchMessage[]

  reservations Reservation[]

}

model Arena {
  id        String   @id @default(cuid())
  name      String
  city      String?
  district  String?
  address   String?
  imageUrl  String?

  openTime  String?  // "09:00"
  closeTime String?  // "23:00"

  // ✅ extras “SaaS”
  pixKey        String?
  hasParking    Boolean @default(false)
  hasLockerRoom Boolean @default(false)
  hasLighting   Boolean @default(false)

  ratingAvg     Float   @default(0)
  ratingCount   Int     @default(0)

  // opcional (se quiser guardar comodidades livres)
  amenities     Json?

  ownerId   String
  owner     User     @relation("ArenaOwnerArenas", fields: [ownerId], references: [id], onDelete: Cascade)

  courts    Court[]
  partnerships PartnerArena[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId])
}

model Court {
  id        String    @id @default(cuid())
  name      String
  type      CourtType @default(FUTSAL)

  city      String?
  address   String?

  // ✅ pertence a uma Arena (novo)
  arenaId   String?
  arena     Arena?    @relation(fields: [arenaId], references: [id], onDelete: SetNull)

  // (LEGADO) dono direto da quadra (pra não quebrar o que já existe)
  arenaOwnerId String?
  arenaOwner   User?   @relation("ArenaOwnerCourts", fields: [arenaOwnerId], references: [id], onDelete: SetNull)

  // ✅ extras da quadra (o que faz sentido ser “por quadra”)
  capacity     Int      @default(14) // maxPlayers sugerido
  pricePerHour Int?     // sugestão para calcular preço por jogador
  covered      Boolean  @default(false)
  surface      String?  // sintético, madeira, cimento, etc (opcional)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  matches   Match[]

  reservations Reservation[]


  @@index([arenaId])
  @@index([arenaOwnerId])
}

model Match {
  id             String    @id @default(cuid())
  title          String
  date           DateTime
  type           CourtType @default(FUT7)

  organizerId    String
  organizer      User      @relation("OrganizerMatches", fields: [organizerId], references: [id], onDelete: Cascade)

  courtId        String?
  court          Court?    @relation(fields: [courtId], references: [id], onDelete: SetNull)

  maxPlayers     Int       @default(14)
  pricePerPlayer Int       @default(30)

  matchAddress   String?   // caso seja manual (sem court) ou override

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  presences      MatchPresence[]
  messages       MatchMessage[]

  @@index([date])
  @@index([organizerId])
  @@index([courtId])
}

model MatchPresence {
  id        String   @id @default(cuid())
  matchId   String
  userId    String

  status    String   @default("confirmed") // confirmed / waitlist / left

  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([matchId, userId])
  @@index([userId])
}

model MatchMessage {
  id        String   @id @default(cuid())
  matchId   String
  userId    String
  text      String

  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([matchId])
}

model PartnerArena {
  id          String   @id @default(cuid())
  organizerId String
  arenaId     String
  status      String   @default("active")

  organizer   User     @relation("OrganizerPartnerships", fields: [organizerId], references: [id], onDelete: Cascade)
  arena       Arena    @relation(fields: [arenaId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([organizerId, arenaId])
  @@index([organizerId])
  @@index([arenaId])
}

enum ReservationStatus {
  PENDING
  CONFIRMED
  CANCELED
}

enum PaymentStatus {
  UNPAID
  PAID
  REFUNDED
}

model Reservation {
  id            String @id @default(cuid())

  courtId        String
  court          Court @relation(fields: [courtId], references: [id], onDelete: Cascade)

  userId         String
  user           User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  startAt        DateTime
  endAt          DateTime

  totalPrice     Int?
  status         ReservationStatus @default(PENDING)
  paymentStatus  PaymentStatus @default(UNPAID)

  notes          String?

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([courtId, startAt])
  @@index([userId])
}
