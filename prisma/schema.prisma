generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  user
  owner        // organizador
  arena_owner  // dono de arena/estabelecimento
  admin
}

enum CourtType {
  FUTSAL
  FUT7
  CAMPO
  VOLEI
  FUTVOLEI
  BEACH_TENNIS
  BASQUETE
  TENIS
  HANDEBOL
  SKATE
  OUTRO
}

model User {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  phone     String?
  imageUrl  String?
  password  String
  role      Role     @default(user)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // (LEGADO) ainda funciona: quadras ligadas direto no arena_owner
  courts Court[] @relation("ArenaOwnerCourts")

  // ‚úÖ arenas do arena_owner
  arenas Arena[] @relation("ArenaOwnerArenas")

  // partidas criadas por organizador
  matches Match[] @relation("OrganizerMatches")

  // parcerias do organizador com arenas
  partnerships PartnerArena[] @relation("OrganizerPartnerships")

  // presen√ßas do usu√°rio nas partidas
  presences MatchPresence[]

  // chat da partida
  messages MatchMessage[]

  reservations Reservation[]

  stats MatchPlayerStat[]
  passwordResetTokens PasswordResetToken[]

  // ‚úÖ perfil p√∫blico (social-lite)
  profile Profile?

  // ‚úÖ pedidos de amizade (facebook)
  friendRequestsSent     FriendRequest[] @relation("FriendRequestsSent")
  friendRequestsReceived FriendRequest[] @relation("FriendRequestsReceived")

  // ‚úÖ amizades (par A/B)
  friendshipsA Friendship[] @relation("FriendshipsA")
  friendshipsB Friendship[] @relation("FriendshipsB")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  tokenHash String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model Arena {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique   // üëà NOVO
  city      String?
  district  String?
  address   String?
  imageUrl  String?

  openTime  String?  // "09:00"
  closeTime String?  // "23:00"

  // ‚úÖ extras ‚ÄúSaaS‚Äù
  pixKey        String?
  hasParking    Boolean @default(false)
  hasLockerRoom Boolean @default(false)
  hasLighting   Boolean @default(false)

  ratingAvg     Float   @default(0)
  ratingCount   Int     @default(0)

  // opcional (se quiser guardar comodidades livres)
  amenities     Json?

  ownerId   String
  owner     User     @relation("ArenaOwnerArenas", fields: [ownerId], references: [id], onDelete: Cascade)

  courts    Court[]
  partnerships PartnerArena[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId])
}

model Court {
  id        String    @id @default(cuid())
  name      String
  type      CourtType @default(FUTSAL)

  city      String?
  address   String?

  // ‚úÖ pertence a uma Arena (OBRIGAT√ìRIO)
  arenaId   String
  arena     Arena     @relation(fields: [arenaId], references: [id], onDelete: Cascade)

  // (LEGADO) pode ficar por enquanto, mas N√ÉO USA mais no app novo
  arenaOwnerId String?
  arenaOwner   User?   @relation("ArenaOwnerCourts", fields: [arenaOwnerId], references: [id], onDelete: SetNull)

  capacity     Int      @default(14)
  pricePerHour Int?
  covered      Boolean  @default(false)
  surface      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  matches   Match[]
  reservations Reservation[]

  @@index([arenaId])
  @@index([arenaOwnerId])
}

enum MatchStatus {
  SCHEDULED   // agendada
  LIVE        // em andamento
  FINISHED    // finalizada
  CANCELED    // cancelada manual
  EXPIRED     // cancelada automaticamente (n√£o fechou / passou do hor√°rio)
}

enum MatchKind {
  BOOKING   // reserva/agenda (privado/operacional)
  PELADA    // partida p√∫blica (entra e participa)
}

model Match {
  id             String    @id @default(cuid())
  title          String
  date           DateTime
  type           CourtType @default(FUT7)

  // ‚úÖ NOVO: diferencia "reserva" vs "pelada"
  kind           MatchKind @default(BOOKING)

  organizerId    String
  organizer      User      @relation("OrganizerMatches", fields: [organizerId], references: [id], onDelete: Cascade)

  // ‚úÖ OBRIGAT√ìRIO
  courtId        String
  court          Court     @relation(fields: [courtId], references: [id], onDelete: Cascade)

  maxPlayers     Int       @default(14)
  pricePerPlayer Int       @default(30)

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  presences      MatchPresence[]
  messages       MatchMessage[]
  stats          MatchPlayerStat[]

  status     MatchStatus @default(SCHEDULED)
  minPlayers Int @default(0)
  startedAt  DateTime?
  finishedAt DateTime?
  canceledAt DateTime?

  @@index([date])
  @@index([organizerId])
  @@index([courtId])
  @@index([kind])
}

model MatchPresence {
  id        String   @id @default(cuid())
  matchId   String
  userId    String

  status    String   @default("confirmed") // confirmed / waitlist / left

  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([matchId, userId])
  @@index([userId])
}

model MatchMessage {
  id        String   @id @default(cuid())
  matchId   String
  userId    String
  text      String

  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([matchId])
}

model MatchPlayerStat {
  id        String   @id @default(cuid())
  matchId   String
  userId    String

  goalsOfficial     Int @default(0)
  assistsOfficial   Int @default(0)

  goalsUnofficial   Int @default(0)
  assistsUnofficial Int @default(0)

  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([matchId, userId])
  @@index([userId])
}

model PartnerArena {
  id          String   @id @default(cuid())
  organizerId String
  arenaId     String
  status      String   @default("active")

  organizer   User     @relation("OrganizerPartnerships", fields: [organizerId], references: [id], onDelete: Cascade)
  arena       Arena    @relation(fields: [arenaId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([organizerId, arenaId])
  @@index([organizerId])
  @@index([arenaId])
}

enum ReservationStatus {
  PENDING
  CONFIRMED
  CANCELED
}

enum PaymentStatus {
  UNPAID
  PAID
  REFUNDED
}

model Reservation {
  id            String @id @default(cuid())

  courtId        String
  court          Court @relation(fields: [courtId], references: [id], onDelete: Cascade)

  userId         String
  user           User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  startAt        DateTime
  endAt          DateTime

  totalPrice     Int?
  status         ReservationStatus @default(PENDING)
  paymentStatus  PaymentStatus @default(UNPAID)

  notes          String?

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // j√° tinha:
  @@index([courtId, startAt])
  @@index([userId])

  // ‚úÖ novos (recomendados)
  @@index([courtId, endAt])
  @@index([courtId, status])
}


model Profile {
  id            String   @id @default(cuid())

  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // identidade p√∫blica
  username      String?  @unique
  bio           String?
  city          String?
  bairro        String?
  coverImageUrl String?

  // futebol (ou esportes) ‚Äî MVP
  position      String?  // "Meia", "Zagueiro", etc
  level         String?  // "Iniciante", "M√©dio", "Avan√ßado"
  foot          String?  // "Destro", "Canhoto", "Ambidestro"

  // tags (ex: ["Futsal", "Resenha", "FUT7"])
  tags          Json?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model FriendRequest {
  id        String   @id @default(cuid())

  fromId    String
  toId      String

  // pending/accepted/declined/canceled (voc√™ decide na API)
  status    String   @default("pending")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  from      User     @relation("FriendRequestsSent", fields: [fromId], references: [id], onDelete: Cascade)
  to        User     @relation("FriendRequestsReceived", fields: [toId], references: [id], onDelete: Cascade)

  // evita spam duplicado
  @@unique([fromId, toId])
  @@index([toId])
  @@index([fromId])
  @@index([status])
}

model Friendship {
  id        String   @id @default(cuid())

  // guardamos sempre ordenado na aplica√ß√£o (A < B)
  userAId   String
  userBId   String

  createdAt DateTime @default(now())

  userA     User     @relation("FriendshipsA", fields: [userAId], references: [id], onDelete: Cascade)
  userB     User     @relation("FriendshipsB", fields: [userBId], references: [id], onDelete: Cascade)

  // garante que n√£o existe amizade duplicada
  @@unique([userAId, userBId])
  @@index([userAId])
  @@index([userBId])
}
