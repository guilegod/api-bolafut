generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  user
  owner        // organizador
  arena_owner  // dono de arena/estabelecimento
  admin
}

enum CourtType {
  FUTSAL
  FUT7
  CAMPO
  VOLEI
  FUTVOLEI
  BEACH_TENNIS
  BASQUETE
  TENIS
  HANDEBOL
  SKATE
  OUTRO
}

model User {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  password  String
  role      Role     @default(user)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // (LEGADO) ainda funciona
  courts Court[] @relation("ArenaOwnerCourts")

  // ✅ arenas do arena_owner
  arenas Arena[] @relation("ArenaOwnerArenas")

  // partidas criadas por organizador
  matches Match[] @relation("OrganizerMatches")

  // parcerias do organizador com arenas
  partnerships PartnerArena[] @relation("OrganizerPartnerships")

  // presenças do usuário nas partidas
  presences MatchPresence[]
  messages       MatchMessage[]   // <- lado oposto do MatchMessage.user
}

model Arena {
  id        String   @id @default(cuid())
  name      String
  city      String?
  district  String?
  address   String?
  imageUrl  String?
  openTime  String?  // "09:00"
  closeTime String?  // "23:00"

  ownerId   String
  owner     User     @relation("ArenaOwnerArenas", fields: [ownerId], references: [id], onDelete: Cascade)

  courts    Court[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId])
}

model Court {
  id        String   @id
  name      String
  type      CourtType @default(FUTSAL)
  city      String?
  address   String?

  // ✅ NOVO: pertence a uma Arena
  arenaId   String?
  arena     Arena?   @relation(fields: [arenaId], references: [id], onDelete: SetNull)

  // (LEGADO) dono direto da quadra (pra não quebrar o que já existe)
  arenaOwnerId String?
  arenaOwner   User? @relation("ArenaOwnerCourts", fields: [arenaOwnerId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  matches   Match[]
}

model Match {
  id            String   @id @default(cuid())
  title         String
  date          DateTime
  type          CourtType @default(FUT7)

  organizerId   String
  organizer     User     @relation("OrganizerMatches", fields: [organizerId], references: [id], onDelete: Cascade)

  courtId       String?
  court         Court?   @relation(fields: [courtId], references: [id], onDelete: SetNull)

  maxPlayers    Int      @default(14)
  pricePerPlayer Int     @default(30)

  matchAddress  String?  // quando for manual (sem court)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  presences     MatchPresence[]
  messages      MatchMessage[]
}

model MatchPresence {
  id        String   @id @default(cuid())
  matchId   String
  userId    String

  status    String   @default("confirmed") // confirmed / waitlist / left

  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([matchId, userId])
}

model MatchMessage {
  id        String   @id @default(cuid())
  matchId   String
  userId    String
  text      String

  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
}

model PartnerArena {
  id          String   @id @default(cuid())
  organizerId String
  arenaId     String
  status      String   @default("active")

  organizer   User     @relation("OrganizerPartnerships", fields: [organizerId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([organizerId, arenaId])
}
